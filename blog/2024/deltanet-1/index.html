<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>DeltaNet Explained (Part I) | Songlin Yang</title> <meta name="author" content="Songlin Yang"> <meta name="description" content="A gentle and comprehensive introduction to the DeltaNet"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/maomao.jpeg?4c57e11efcfd0cc3186dbb6930d90ab5"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sustcsonglin.github.io/blog/2024/deltanet-1/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "DeltaNet Explained (Part I)",
      "description": "A gentle and comprehensive introduction to the DeltaNet",
      "published": "December 3, 2024",
      "authors": [
        {
          "author": "Songlin Yang",
          "authorURL": "https://sustcsonglin.github.io/",
          "affiliations": [
            {
              "name": "MIT CSAIL",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Songlin </span>Yang</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>DeltaNet Explained (Part I)</h1> <p>A gentle and comprehensive introduction to the DeltaNet</p> </d-title><d-byline></d-byline><d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#linear-attention-as-rnn">Linear attention as RNN</a></div> <ul> <li><a href="#what-is-linear-attention">What is linear attention?</a></li> <li><a href="#no-free-lunch-key-limitations-of-linear-attention">No Free Lunch: Key Limitations of Linear Attention</a></li> </ul> <div><a href="#deltanet-linear-attention-with-delta-rule">DeltaNet: Linear Attention with Delta Rule</a></div> <ul> <li><a href="#what-is-delta-rule">What is Delta Rule?</a></li> <li><a href="#what-is-deltanet">What is DeltaNet?</a></li> <li><a href="#deltanet-as-a-strong-in-context-learning-rnn">DeltaNet as a Strong In-context Learning RNN</a></li> <li><a href="#why-is-deltanet-superior-at-in-context-retrieval-than-linear-attention">Why is DeltaNet Superior at In-context Retrieval than Linear Attention?</a></li> </ul> </nav> </d-contents> <p>This is a blogpost accompanying our recent NeurIPS ‘24 publication - <a href="https://arxiv.org/abs/2406.06484" rel="external nofollow noopener" target="_blank">Parallelizing Linear Transformers with the Delta Rule over Sequence Length</a>. (<a href="https://github.com/sustcsonglin/flash-linear-attention/blob/main/fla/layers/delta_net.py" rel="external nofollow noopener" target="_blank">code</a>, <a href="https://people.csail.mit.edu/yoonkim/data/efficient_architecture\mathbf{S}_talk.pdf" rel="external nofollow noopener" target="_blank">slides</a>).</p> <h2 id="linear-attention-as-rnn">Linear attention as RNN</h2> <p>Notations: we use CAPITAL BOLD letters to represent matrices, lowercase bold letters to represent vectors, and regular lowercase letters to represent scalars.</p> <h3 id="what-is-linear-attention">What is linear attention?</h3> <p>The vanilla softmax attention mechanism, though powerful, suffers from quadratic complexity in sequence length. Let’s see how linear attention addresses this issue by starting with the standard softmax attention (assuming single head):</p> \[\begin{aligned} \mathrm{Parallel\ training:} &amp;&amp;&amp; \mathbf{O} = \mathrm{softmax}(\mathbf{Q}\mathbf{K}^\top \odot \mathbf{M})\mathbf{V} &amp;&amp;\in \mathbb{R}^{L\times d} \\ \mathrm{Iterative\ inference:} &amp;&amp;&amp;\mathbf{o_t} = \sum_{j=1}^t \frac{\exp(\mathbf{q}_t^\top \mathbf{k}_j)}{\sum_{l=1}^t\exp(\mathbf{q}^\top_t \mathbf{k}_l)}\mathbf{v}_j &amp;&amp;\in \mathbb{R}^d \end{aligned}\] <p>Here,</p> <ul> <li> <p>\(L\) represents sequence length</p> </li> <li> <p>\(d\) represents head dimension</p> </li> <li> <p>\(\mathbf{Q}, \mathbf{K}, \mathbf{V}, \mathbf{O} \in \mathbb{R}^{L \times d}\) represent the query, key, value, and output matrices respectively.</p> </li> <li> <p>\(\mathbf{M} \in \mathbb{R}^{L \times L}\) is the causal mask for autoregressive modeling by ensuring each position can only attend to previous positions.</p> </li> </ul> <p>What linear attention<d-cite key="katharopoulos2020transformers"></d-cite> does is to simply remove the softmax operator <d-footnote>While the original linear attention formulation includes (1) feature map on queries and keys and a normalizer term, recent work suggests that they are not neccessary.</d-footnote>:</p> \[\begin{aligned} \mathrm{Parallel\ training：} &amp;&amp;&amp;\mathbf{O}= (\mathbf{Q}\mathbf{K}^\top \odot \mathbf{M})\mathbf{V} &amp;&amp;\in \mathbb{R}^{L\times d} \\ \mathrm{Iterative\ inference：}&amp;&amp;&amp;\mathbf{o_t} = \sum_{j=1}^t (\mathbf{q}_t^\top \mathbf{k}_j) \mathbf{v}_j &amp;&amp;\in \mathbb{R}^d \end{aligned}\] <p>While removing softmax alone doesn’t immediately reduce computational complexity, it enables a crucial mathematical property: linearity. This property, particularly associativity, allows us to restructure the computations in ways that significantly improve efficiency. For training, researchers have developed <strong>chunkwise parallel</strong> techniques<d-cite key="GAU"></d-cite><d-cite key="sun2023retentive"></d-cite><d-cite key="yang_gated_2023"></d-cite> that leverage this linearity to achieve subquadratic complexity while maintaining hardware efficiency, which forms the foundation of our open-source <strong>flash-linear-attention</strong> library<d-cite key="yang_fla_2024"></d-cite>.</p> <p>For inference, we can also rearrange the computation as follows:</p> <p>\(\begin{aligned} &amp;&amp;&amp;&amp;\mathbf{o_t} = \sum_{j=1}^t \mathbf{v}_j(\mathbf{k}_j^\top \mathbf{q}_t) &amp;&amp;&amp;&amp;&amp; (\mathbf{k}_j^\top \mathbf{q}_t) = (\mathbf{q}_t^\top \mathbf{k}_j) \in \mathbb{R}\\ &amp;&amp;&amp;&amp;= (\sum_{j=1}^t\mathbf{v}_j\mathbf{k}_j^\top)\mathbf{q}_t &amp;&amp;&amp;&amp;&amp;\text{By associativity} \end{aligned}\) $$</p> <p>Let’s define a state matrix \(\mathbf{S}_t = \sum_{j=1}^t\mathbf{v}_j\mathbf{k}_j^\top\). Then the computation can be expressed as:</p> \[\mathbf{S}_t = \mathbf{S}_{t-1} + \mathbf{v}_t\mathbf{k}_t^\top \in \mathbb{R}^{d\times d}, \quad \mathbf{o}_t = \mathbf{S}_t \mathbf{q}_t \in \mathbb{R}^{d}\] <p>This formulation reveals that linear attention is essentially a <strong>linear RNN with a matrix-valued state</strong> \(\mathbf{S}\) that accumulates key-value outer products, enabling efficient state (size) expansion from \(\mathcal{O}(d)\) to \(\mathcal{O}(d^2)\).</p> <details> <summary> Why do we want state expansion?</summary> Traditionally, RNN's hidden dimension is often the same (or of the same magnitude) as the input dimension, due to the expensive matrix-multiply-based state update. However, RNN solely relies on the recurrent state to remember the entire history and state size tends to be the bottleneck to remember sufficient amount of information, especially in retrieval tasks. We've been observing a substantial amount of research investigating hardware-efficient state expansion since Mamba1<d-cite key="Gu2023MambaLS"></d-cite> explicitly pointed it out, and linear attention styled outer-product-based update has proven to be optimal in terms of efficiently scaling state up (Mamba2<d-cite key="mamba2"></d-cite> also adopts this strategy!). In our previous HGRN2 work<d-cite key="qin_hgrn2_2024"></d-cite>, we investigated different approaches for state expansion, and the outer product based mechanism has proven to be both performant and scalable. </details> <p>With this approach, we only need to store and update \(\mathbf{S}_t\) instead of maintaining all previous key-value pairs. This optimization dramatically improves efficiency: the time complexity for autoregressive inference reduces from \(\mathcal{O}(L^2d)\) to \(\mathcal{O}(Ld^2)\), while the space complexity improves from \(\mathcal{O}(Ld)\) to \(\mathcal{O}(d^2)\). These improvements make this method particularly advantageous in two scenarios:</p> <ul> <li> <p><strong>Long sequence modeling</strong> where quadratic complexity of softmax attention could be a significant bottleneck.</p> </li> <li> <p>During <strong>generation</strong>, where computation is usually <strong>memory-bound</strong>, removing the KV cache can significantly enhance <strong>inference latency</strong> for \(L \gg d\).</p> </li> </ul> <h3 id="no-free-lunch-key-limitations-of-linear-attention">No Free Lunch: Key Limitations of Linear Attention</h3> <p>Unfortunately, there is no free lunch. The fixed-size state matrix in linear attention means it cannot perfectly preserve all historical information, making exact retrieval particularly challenging.</p> <p>More formally, linear attention implements a key-value associative memory, which is the sum of outer products between keys and values \(\mathbf{S} = \sum \mathbf{v}_i\mathbf{k}_i^\top\). Assuming all keys are normalized to unit length, when we try to retrieve a value associated with a specific key \(k_j\), we get:</p> \[\begin{aligned} \mathbf{S}\mathbf{k}_j &amp;= \sum \mathbf{v}_i (\mathbf{k}_i^\top \mathbf{k}_j) \\ &amp;= \mathbf{v}_j + \underbrace{\sum_{i\neq j} (\mathbf{k}_i^\top \mathbf{k}_j)\mathbf{v}_i}_{\text{retrieval error}} \end{aligned}\] <p>To minimize the retrieval error term, we need \(\mathbf{k}_i^\top \mathbf{k}_j = 0\) for all \(i\neq j\) - in other words, all keys should be <strong>orthogonal</strong> to each other. However, this reveals a fundamental limitation: in a \(d\)-dimensional space, you can only have at most \(d\) orthogonal vectors. This explains why increasing head dimension helps (For example, Sun et al.<d-cite key="sun2023retentive"></d-cite> have demonstrated the necessity of increasing head dimensions to enhance model performance) - it provides more “room” in the vector space for storing distinct key-value pairs!</p> <p>This theoretical limitation manifests in practice: vanilla linear attention has underperformed compared to softmax attention (by a large marghin) in language modeling. The primary cause is memory “overload”: in this key-value associative memory system, we can only add new key-value associations without the ability to erase existing information. As sequences grow longer, this leads to accumulating “retrieval errors” that degrade performance.</p> <blockquote> <p>“The enemy of memory is not time; it’s other memories…” — David Eagleman. h/t to Kazuki Irie for the quote reference</p> </blockquote> <p>Recent advances in gated variants of linear attention (such as GLA<d-cite key="yang_gated_2023"></d-cite> and Mamba<d-cite key="Gu2023MambaLS"></d-cite>) have significantly narrowed the performance gap with standard attention in language modeling tasks by incorporating a <strong>forgetting mechanism</strong>. However, these models still face fundamental challenges with in-context retrieval and exact copying capabilities—limitations that have been both empirically observed and theoretically proven in recent work<d-cite key="zoology"></d-cite><d-cite key="arora_simple_2024"></d-cite><d-cite key="jelassi_repeat_2024"></d-cite>.</p> <details> <summary>Click here to learn more about gated variants of linear attention</summary> Given the close relationship between linear attention and RNN, it is no wonder that researchers want to enhance linear attention with the (forgetting) gating mechanisms, which has been shown unreasonably effective in nonlinear RNN<d-cite key="unreasonable-forget-gate"></d-cite> and linear RNN<d-cite key="HGRN"></d-cite>: <p> </p> <p> \[\mathbf{S}_t = \mathbf{G}_t \odot \mathbf{S}_{t-1} + \mathbf{v}_t\mathbf{k}_t^\top\] </p> <p> with different structured parameterization for \(\mathbf{G}_t \in \mathbb{R}^{d\times d}\) for parameter efficiency, often with outer product structure. Different models have proposed various ways to structure this gating matrix: </p> <p> For Decaying Fast weight<d-cite key="mao_fine-tuning_2022"></d-cite>: \[\mathbf{G}_t = \mathbf{\beta_t} \mathbf{\alpha_t}^\top\] </p> <p> For GLA<d-cite key="yang_gated_2023"></d-cite>: \[\mathbf{G}_t = \mathbf{1} \mathbf{\alpha_t}^\top\] </p> <p> For Mamba1<d-cite key="Gu2023MambaLS"></d-cite>: \[\mathbf{G}_t = \exp(-(\mathbf{\Delta_t} \mathbf{1}^\top) \odot \exp(A))\] </p> <p> For Mamba2<d-cite key="mamba2"></d-cite>: \[\mathbf{G}_t = \gamma_t \mathbf{1}\mathbf{1}^\top\] </p> <p> Cf. Table 1 of GLA<d-cite key="yang_gated_2023"></d-cite> for a summarization. </p> </details> <h2 id="deltanet-linear-attention-with-delta-rule">DeltaNet: Linear Attention with Delta Rule</h2> <h3 id="what-is-delta-rule">What is Delta Rule?</h3> <p>The Delta Rule<d-cite key="widrow_adaptive_1988"></d-cite> is a fundamental error-correction learning principle in neural networks. Its fcore idea is beautifully simple: adjust the model’s parameters based on the difference (delta) between what we want (target) and what we actually get (prediction).</p> <p>To understand this intuitively, imagine teaching a child to aim at a target. If they shoot too far to the left, you’d tell them to adjust right; too far right, adjust left. The size of the adjustment depends on how far they missed - a concept directly reflected in the Delta Rule.</p> <details> <summary>Click to expand Delta Rule code</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">delta_rule</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Simple delta rule implementation
    x: input features (N samples by D features)
    y: target values (N samples)
    </span><span class="sh">"""</span>
    <span class="c1"># Initialize weights
</span>    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Train
</span>    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="c1"># Forward pass
</span>            <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
            
            <span class="c1"># Compute error
</span>            <span class="n">error</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">pred</span>
            
            <span class="c1"># Update weights
</span>            <span class="n">w</span> <span class="o">+=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">error</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
    <span class="k">return</span> <span class="n">w</span>

<span class="c1"># Example usage
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="c1"># Generate toy data
</span>    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 100 samples, 3 features
</span>    <span class="n">true_w</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">true_w</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    
    <span class="c1"># Train
</span>    <span class="n">w</span> <span class="o">=</span> <span class="nf">delta_rule</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">True weights:</span><span class="sh">"</span><span class="p">,</span> <span class="n">true_w</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Learned weights:</span><span class="sh">"</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span></code></pre></figure> </details> <h3 id="what-is-deltanet">What is DeltaNet?</h3> <p>DeltaNet<d-cite key="schlag_linear_2021"></d-cite> applies this error-correction principle to linear attention. Instead of simply accumulating key-value outer product, it updates its state based on prediction errors:</p> \[\mathbf{S}_{t} = \mathbf{S}_{t-1} - \beta_t(\mathbf{S}_{t-1} \mathbf{k}_t - \mathbf{v}_t)\mathbf{k}_t^\top = \mathbf{S}_{t-1} - \beta_t \mathbf{S}_{t-1} \mathbf{k}_t \mathbf{k}_t^\top + \beta_t \mathbf{v}_t \mathbf{k}_t^\top\] <p>The parallel to the Delta Rule becomes clear when we break down the components:</p> <ul> <li>\(\beta_t \in \mathbb{R}\) acts as the learning rate</li> <li>\(\mathbf{k}_t \in \mathbb{R}^d\) is the input data</li> <li>\(\mathbf{v}_t \in \mathbb{R}^d\) is the target</li> <li>\(\mathbf{S}_{t-1} \mathbf{k}_t \in \mathbb{R}^d\) is our current prediction</li> </ul> <p>We will revisit this form later, showing how it can emerge naturally from a single gradient descent step on a (online) loss function.</p> <p>There’s another intuitive way to understand this update rule. Think of \(\mathbf{S}_{t-1}\mathbf{k}_t\) as retrieving the “old value” associated with the current key \(\mathbf{k}_t\) from memory. When we encounter a newly associated value \(\mathbf{v}_t\) for the same key, rather than blindly overwriting, we make a careful update:</p> \[\mathbf{v}_t^{\text{new}} = (1-\beta_t) \mathbf{v}_t^{\text{old}} + \beta_t \mathbf{v}_t, \qquad \mathbf{S}_t = \mathbf{S}_{t-1} - \underbrace{\mathbf{v}_t^{\text{old}} \mathbf{k}_t^\top}_{\text{erase}} + \underbrace{\mathbf{v}_t^{\text{new}} \mathbf{k}_t^\top}_{\text{write}}\] <p>where \(\mathbf{v}_t^{\text{new}}\) is a learned combination of the old and current values, controlled by a dynamic \(\beta_t \in (0,1)\): when \(\beta_t=0\), the memory content remains intact, and when \(\beta_t=1\), we completely replace the old associated value with the new one.</p> <h3 id="deltanet-as-a-strong-in-context-learning-rnn">DeltaNet as a Strong In-context Learning RNN</h3> <p>MQAR (Multi-Query Associative Recall)<d-cite key="zoology"></d-cite> is a recent popular synthetic benchmark aimed at measuring the in-context associative recall ability for subquadratic models.</p> <p>The MQAR task works as follows: Each letter is associated with a number, and the model is asked to correctly recall the number associated with each letter in a query sequence.</p> <p>For example, given the input:</p> <p><code class="language-plaintext highlighter-rouge">A 4 B 3 C 6 F 1 E 2 → A ? C ? F ? E ? B ?</code></p> <p>The format consists of:</p> <ol> <li>Key-Value pairs (before the arrow): Letters paired with their corresponding numbers</li> <li>Query sequence (after the arrow): Letters whose associated numbers need to be recalled</li> </ol> <p>The correct output for this example would be:</p> <p><code class="language-plaintext highlighter-rouge">4, 6, 1, 2, 3</code></p> <p>While conventional gated convolution and recurrent models generally underperform in this task, in our experiments, we show that DeltaNet <d-footnote>Fun fact: DeltaNet was originally designed to enhance associative recall performance</d-footnote> demonstrates notably strong performance:</p> <div class="row justify-content-center"> <div class="col-6"> <img class="img-fluid" style="background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);" src="/assets/img/blog/deltanet/mqar-1.png"> </div> </div> <div class="caption"> The hardest setting from the original Zoology paper </div> <p>This initial success was particularly exciting—achieving perfect performance on MQAR exceeded our expectations. What makes this result especially promising is that MQAR performance strongly correlates with “Associative-Recall-Hit” in real-world language modeling tasks<d-cite key="zoology"></d-cite>. Associative recall failures are a primary source of errors in subquadratic models and largely account for their perplexity gap relative to softmax attention. Thus, DeltaNet’s perfect MQAR performance suggested significant potential.</p> <p>We’ve also conducted experiments on MAD<d-cite key="poli_mechanistic_2024"></d-cite>, another more comprehensive benchmark than MQAR that is also motivated to test new architecture’s capacities, and the results are summarized below:</p> <table> <thead> <tr> <th>Model</th> <th>Compress</th> <th>Fuzzy Recall</th> <th>In-Context Recall</th> <th>Memorize</th> <th>Noisy Recall</th> <th>Selective Copy</th> <th>Average</th> </tr> </thead> <tbody> <tr> <td>Transformer</td> <td>51.6</td> <td>29.8</td> <td>94.1</td> <td>85.2</td> <td>86.8</td> <td>99.6</td> <td>74.5</td> </tr> <tr> <td>Hyena</td> <td>45.2</td> <td>7.9</td> <td>81.7</td> <td>89.5</td> <td>78.8</td> <td>93.1</td> <td>66.0</td> </tr> <tr> <td>Multihead Hyena</td> <td>44.8</td> <td>14.4</td> <td>99.0</td> <td>89.4</td> <td>98.6</td> <td>93.0</td> <td>73.2</td> </tr> <tr> <td>Mamba</td> <td>52.7</td> <td>6.7</td> <td>90.4</td> <td>89.5</td> <td>90.1</td> <td>86.3</td> <td>69.3</td> </tr> <tr> <td>GLA</td> <td>38.8</td> <td>6.9</td> <td>80.8</td> <td>63.3</td> <td>81.6</td> <td>88.6</td> <td>60.0</td> </tr> <tr> <td>DeltaNet</td> <td>42.2</td> <td>35.7</td> <td>100</td> <td>52.8</td> <td>100</td> <td>100</td> <td>71.8</td> </tr> </tbody> </table> <p>where DeltaNet demonstrates its strong in-context recall capacities. These synthetic tasks are inexpensive to run and offer clear evidence that DeltaNet is likely to perform well at scale. This motivated us to focus on developing DeltaNet’s training algorithm and kernel implementation—after all, scaling up an arbitrary architecture without demonstrating its potential would risk wasting significant time and resources.</p> <p>In the next post, we’ll explore a beautiful algorithm that parallelizes DeltaNet across sequence length. But first, let’s build some intuition about why DeltaNet is particularly well-suited for in-context retrieval tasks.</p> <h3 id="why-is-deltanet-superior-at-in-context-retrieval-compared-to-linear-attention">Why is DeltaNet Superior at In-context Retrieval Compared to Linear Attention?</h3> <p>DeltaNet’s update rule can be derived by sequentially minimizing the mean squared error (MSE) between the desired output and the predicted output using gradient descent: <d-footnote>This formulation reveals an interesting connection to Test-Time-Training (TTT) <d-cite key="sun-2024-learning"></d-cite>: DeltaNet becomes mathematically equivalent to TTT-linear under two specific conditions: (1) when nonlinear components such as layer normalization are removed, and (2) when the mini-batch size in TTT is set to one.</d-footnote></p> \[L(\mathbf{S}) = \frac{1}{2}\|\mathbf{S} \mathbf{k}_t - \mathbf{v}_t\|^2_F\] <p>Applying gradient descent to minimize this MSE loss gives:</p> \[\begin{aligned} \mathbf{S}_t &amp;= \mathbf{S}_{t-1} - \eta_t \nabla L(\mathbf{S}_{t-1}) \\ &amp;= \mathbf{S}_{t-1} - \eta_t \left(\mathbf{S}_{t-1} \mathbf{k}_t - \mathbf{v}_t\right) \mathbf{k}_t^\top \end{aligned}\] <p>When the learning rate $\eta_t$ is set to $\beta_t$, this results in DeltaNet’s update rule.</p> <p>In contrast, vanilla linear attention employs a linear loss function:</p> \[L^\prime(\mathbf{S}) = -\langle \mathbf{S} \mathbf{k}_t, \mathbf{v}_t \rangle_F\] <p>The corresponding update rule for linear attention is:</p> \[\begin{aligned} \mathbf{S}_t &amp;= \mathbf{S}_{t-1} - \eta_t \nabla L^\prime(\mathbf{S}_{t-1}) \\ &amp;= \mathbf{S}_{t-1} + \eta_t \mathbf{v}_t \mathbf{k}_t^\top \end{aligned}\] <p>By setting $\eta_t = 1$, the standard linear attention update is recovered.</p> <p>Now DeltaNet’s better performance in in-context retrieval makes sense—it uses an MSE-based optimization framework that explicitly corrects errors at each update, unlike the simpler additive updates in linear attention.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2024-12-03-delta.bib"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"sustcsonglin/sustcsonglin.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Songlin Yang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>